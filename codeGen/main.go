package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"strconv"
	"strings"
)

const dataFileName = "imageTagDataExtract.txt"
const templateFileName = "imageTagDataTemplate.go"
const generatedFileName = "../imageTagDataGenerated.go"

var MapDirTags = map[uint32]bool{
	TagSubIFD0:                true,
	TagExifSubIFD:             true,
	TagGPSIFD:                 true,
	TagInteroperabilityIFD:    true,
	TagExtraCameraProfilesIFD: true,
}

func newTagFormat(format TiffFormat, formatName string, desc string, byteLen uint32) *TagFormat {
	return &TagFormat{
		tiffFormat: format,
		formatName: formatName,
		byteLen:    byteLen,
		desc:       desc,
	}
}

var mapTiffFormatsTest = map[string]*TagFormat{
	"Byte":     newTagFormat(FormatUint8, "FormatUint8", "Byte Int8", 1),
	"Ascii":    newTagFormat(FormatString, "FormatString", "ASCII String", 1),
	"Comment":  newTagFormat(FormatString, "FormatString", "ASCII String", 1),
	"Short":    newTagFormat(FormatUint16, "FormatUint16", "Short Uint16", 2),
	"Long":     newTagFormat(FormatUint32, "FormatUint32", "Long Uint32", 4),
	"Rational": newTagFormat(FormatURational, "FormatURational", "n/d URational", 8),
	"SByte":    newTagFormat(FormatInt8, "FormatInt8", "Byte Signed Int8", 1),
	// There is no 6
	"Undefined": newTagFormat(FormatUndefined, "FormatUndefined", "Undefined", 1),
	//. There is no 8
	"SLong":     newTagFormat(FormatInt32, "FormatInt32", "Long int32", 4),
	"SRational": newTagFormat(FormatRational, "FormatRational", "n/d Rational", 8),
	"SShort":    newTagFormat(FormatInt16, "FormatInt16", "Short int16", 2),
	"Float":     newTagFormat(FormatFloat32, "FormatFloat32", "Single Float32", 2),
	"Double":    newTagFormat(FormatFloat64, "FormatFloat64", "Double Float64", 4),
}

func main() {
	mapDupeTags := make(map[string]map[int]bool)

	var mapTagsGenerated bytes.Buffer
	mapTreeBuff := make(map[string]*bytes.Buffer)

	mapTagsGenerated.WriteString("//\n")
	mapTagsGenerated.WriteString("// Generated from input data file WebScrapeEXIFData.txt extracted from https://exiv2.org/tags.html\n")
	mapTagsGenerated.WriteString("// Run the code generator in codeGen.\n")
	mapTagsGenerated.WriteString("var MapTagsGrouped = map[string]map[uint32]*Tag{\n")

	// Add the known tags for sub directories
	var mapTiffFormatsGenerated bytes.Buffer
	mapTiffFormatsAdded := make(map[string]bool)
	mapTiffFormatsGenerated.WriteString("//\n")
	mapTiffFormatsGenerated.WriteString("// Generated from input data file WebScrapeEXIFData.txt extracted from https://exiv2.org/tags.html\n")
	mapTiffFormatsGenerated.WriteString("// Run the code generator in codeGen.\n")
	mapTiffFormatsGenerated.WriteString("var MapTiffFormats = map[TiffFormat]*TagFormat{\n")
	dataFile, err := os.Open(dataFileName)
	if err != nil {
		panic(err)
	}
	defer dataFile.Close()
	fmt.Printf("Reading tag and format data from %s\n", dataFileName)
	scanner := bufio.NewScanner(dataFile)
	ln := 1
	for scanner.Scan() {
		l := scanner.Text()
		ll := strings.SplitAfterN(l, " ", 6) // ll is the line split by space
		lls := make([]string, len(ll))       // lls is the line splits stripped of spaces
		for i, s := range ll {
			lls[i] = strings.TrimSpace(s)
		}
		tagNumber := lls[1]
		tagPath := lls[3]
		tagFormat := lls[4]
		lonDesc := strings.ReplaceAll(lls[5], "\"", "\\\"") // Replave " with \" in description
		tag, e := strconv.Atoi(tagNumber)                   // tag is the integer tag number
		if e != nil {
			panic(fmt.Sprintf("Integer conversion failed [%s] %s Line %d\n", tagNumber, tagFormat, ln))
		}
		//
		// Deal with Tiff formats
		//
		v, found := mapTiffFormatsTest[tagFormat]
		if found {
			_, added := mapTiffFormatsAdded[v.formatName]
			if !added {
				mapTiffFormatsGenerated.WriteString(fmt.Sprintf("  %s: {tiffFormat:%s, formatName:\"%s\", desc:\"%s\", byteLen:%d},\n", v.formatName, v.formatName, v.formatName, v.desc, v.byteLen))
				mapTiffFormatsAdded[v.formatName] = true
			}
			tagPathParts := strings.Split(tagPath, ".")

			groupName, found := MapGroupName[tagPathParts[1]]
			if !found {
				groupName = MapGroupName[GroupNameRoot]
			}

			tagGroup, found := MapDirTagsToGroup[uint32(tag)]
			if !found {
				tagGroup = MapDirTagsToGroup[TagSubIFD0]
			}

			tagName := tagPathParts[2]
			/*
				var mapTagsGrouped = map[string]map[uint32]*Tag{
					"A": {
						1: {IsDir: false, TagNum: 1, Name: "NameA1", TagGroup: "A", validFormats: []TiffFormat{FormatUndefined}, LongDesc: "LongA1"},
						2: {IsDir: false, TagNum: 1, Name: "NameA2", TagGroup: "A", validFormats: []TiffFormat{FormatUndefined}, LongDesc: "LongA2"},
					},
					"B": {
						1: {IsDir: false, TagNum: 1, Name: "NameA1", TagGroup: "B", validFormats: []TiffFormat{FormatUndefined}, LongDesc: "LongA1"},
						2: {IsDir: false, TagNum: 1, Name: "NameA2", TagGroup: "B", validFormats: []TiffFormat{FormatUndefined}, LongDesc: "LongA2"},
					},
				}
			*/
			buff, ok := mapTreeBuff[groupName]
			if !ok {
				buff = &bytes.Buffer{}
				mapTreeBuff[groupName] = buff
			}
			_, isDir := MapDirTags[uint32(tag)]

			if !isDir {
				tagGroup = groupName
			}

			_, found = mapDupeTags[groupName]
			if !found {
				mapDupeTags[groupName] = make(map[int]bool)
			}
			_, found = mapDupeTags[groupName][tag]
			if !found {
				mapDupeTags[groupName][tag] = true
				//TagNum: {IsDir: false, TagNum: 1, Name: "NameA1", TagGroup: "A", validFormats: []TiffFormat{FormatUndefined}, LongDesc: "LongA1"},
				buff.WriteString(fmt.Sprintf("   %d:{IsDir: %t, TagNum: %d,  Name: \"%s\",  TagGroup: \"%s\", validFormats: []TiffFormat{%s}, LongDesc: \"%s\"},\n", tag, isDir, tag, tagName, tagGroup, v.formatName, lonDesc))
			} else {
				buff.WriteString(fmt.Sprintf("// %d:{IsDir: %t, TagNum: %d,  Name: \"%s\",  TagGroup: \"%s\", validFormats: []TiffFormat{%s}, LongDesc: \"%s\"},\n", tag, isDir, tag, tagName, tagGroup, v.formatName, lonDesc))
			}
		} else {
			panic(fmt.Sprintf("Tiff format (type) Not Found %s Line %d\n", tagFormat, ln))
		}

		ln++
	}
	v := mapTiffFormatsTest["SLong"]

	mapTiffFormatsGenerated.WriteString(fmt.Sprintf("  %s: {tiffFormat:%s, formatName:\"%s\", desc:\"%s\", byteLen:%d},// Added. It is not in data file WebScrapeEXIFData.txt: SLong\n", v.formatName, v.formatName, v.formatName, v.desc, v.byteLen))
	v = mapTiffFormatsTest["SByte"]
	mapTiffFormatsGenerated.WriteString(fmt.Sprintf("  %s: {tiffFormat:%s, formatName:\"%s\", desc:\"%s\", byteLen:%d},// Added. There is no spec for: SByte\n", v.formatName, v.formatName, v.formatName, v.desc, v.byteLen))
	mapTiffFormatsGenerated.WriteString("}\n")

	for k, buff := range mapTreeBuff {
		mapTagsGenerated.WriteString(fmt.Sprintf("\"%s\": { // Group!\n", k))
		mapTagsGenerated.WriteString(buff.String())
		mapTagsGenerated.WriteString("},\n")
	}

	mapTagsGenerated.WriteString("}\n")

	template, err := os.Open(templateFileName)
	if err != nil {
		panic(err)
	}
	defer template.Close()
	fmt.Printf("Reading tempalte from %s\n", templateFileName)

	op, err := os.Create(generatedFileName)
	if err != nil {
		panic(err)
	}
	defer op.Close()
	fmt.Printf("Writing generated code to %s\n", generatedFileName)

	tScanner := bufio.NewScanner(template)
	for tScanner.Scan() {
		l := tScanner.Text()
		if strings.Contains(l, CodeGenBarrier) {
			op.WriteString(mapTiffFormatsGenerated.String())
			op.WriteString(mapTagsGenerated.String())
			break
		} else {
			op.WriteString(l)
			op.WriteString("\n")
		}
	}
}
