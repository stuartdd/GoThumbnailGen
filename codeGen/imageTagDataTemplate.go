package main

/*
DO NOT EDIT THE GENERATED FILE

If a change is required then edit ~/codeGen/imageTagDataTemplate.go

The code is generated by the codeGen system.
	``
	cd codeGen
	go run .
	``
	Or using ./run in the main directory

	The template file is read, updated and replaces the generated file
	The template file must compile and run as part of the codeGen system
*/

import (
	"fmt"
)

type TiffFormat uint16

const TagExifVersion uint32 = 36864

// 0x014a 	330 	Image 	Exif.Image.SubIFDs 	Long 	Defined by Adobe Corporation to enable TIFF Trees within a TIFF file.
const TagSubIFD0 uint32 = 330

// 0x8769 	34665 	Image 	Exif.Image.ExifTag 	Long 	A pointer to the Exif IFD. Interoperability, Exif IFD has the same structure as that of the IFD specified in TIFF. ordinarily, however, it does not contain image data as in the case of TIFF.
const TagExifSubIFD uint32 = 34665

// 0x8825 	34853 	Image 	Exif.Image.GPSTag 	Long 	A pointer to the GPS Info IFD. The Interoperability structure of the GPS Info IFD, like that of Exif IFD, has no image data.
const TagGPSIFD uint32 = 34853

// 0xa005 	40965 	Photo 	Exif.Photo.InteroperabilityTag 	Long 	Interoperability IFD is composed of tags which stores the information to ensure the Interoperability and pointed by the following tag located in Exif IFD. The Interoperability structure of Interoperability IFD is the same as TIFF defined IFD structure but does not contain the image data characteristically compared with normal TIFF IFD.
const TagInteroperabilityIFD uint32 = 40965

// 0xc6f5 	50933 	Image 	Exif.Image.ExtraCameraProfiles 	Long 	A list of file offsets to extra Camera Profile IFDs. Note that the primary camera profile tags should be stored in IFD 0, and the ExtraCameraProfiles tag should only be used if there is more than one camera profile stored in the DNG file.
const TagExtraCameraProfilesIFD uint32 = 50933

/*
Enum of format types
*/
const (
	FormatUint8     TiffFormat = iota + 1 // 1 An 8-bit unsigned integer.
	FormatString                          // 2 An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.
	FormatUint16                          // 3 A 16-bit (2-byte) unsigned integer,
	FormatUint32                          // 4 LONG - A 32-bit (4-byte) unsigned integer,
	FormatURational                       // 5 Two LONGs. The first LONG is the numerator and the second LONG expresses the denominator.
	FormatInt8                            // 6 There is no 6!
	FormatUndefined                       // 7 An 8-bit byte that may take any value depending on the field definition
	FormatInt16                           // 8 There is no 8!
	FormatInt32                           // 9 SLONG - A 32-bit (4-byte) signed integer (2's complement notation).
	FormatRational                        // 10 Two SLONGs. The first SLONG is the numerator and the second SLONG is the denominator.
	FormatFloat32                         // 11 Float
	FormatFloat64                         // 12 Double
)

type Tag struct {
	IsDir        bool
	TagNum       uint32
	Name         string
	TagGroup     string
	validFormats []TiffFormat
	LongDesc     string
}

func (p *Tag) String() string {
	return fmt.Sprintf("%s: %s", p.Name, p.LongDesc)
}

type TagFormat struct {
	tiffFormat TiffFormat
	formatName string
	byteLen    uint32
	desc       string
}

func (p *TagFormat) String() string {
	return fmt.Sprintf("id:%d bytes:%d: type:%s", p.tiffFormat, p.byteLen, p.desc)
}

func LookUpTagFormat(formatId TiffFormat) *TagFormat {
	ta, ok := MapTiffFormats[formatId]
	if !ok {
		return MapTiffFormats[FormatUndefined]
	}
	return ta
}

func LookUpTagData(tag uint32, group string) *Tag {
	tags, ok := MapTagsGrouped[group]
	if !ok {
		return &Tag{
			TagNum:       tag,
			Name:         fmt.Sprintf("Undefined Tag Group:%s:0x%4x", group, tag),
			validFormats: []TiffFormat{FormatUndefined},
			LongDesc:     "",
		}
	}
	ta, ok := tags[tag]
	if !ok {
		return &Tag{
			TagNum:       tag,
			Name:         fmt.Sprintf("Undefined Tag:%s:0x%4x", group, tag),
			validFormats: []TiffFormat{FormatUndefined},
			LongDesc:     "",
		}
	}
	return ta
}

const GroupNameRoot = "Idf0"
const GroupNameIOP = "Iop"
const GroupNameGPS = "GPSInfo"

var MapDirTagsToGroup = map[uint32]string{
	TagSubIFD0:                GroupNameRoot,
	TagExifSubIFD:             GroupNameRoot,
	TagGPSIFD:                 GroupNameGPS,
	TagInteroperabilityIFD:    GroupNameIOP,
	TagExtraCameraProfilesIFD: GroupNameRoot,
}

var MapGroupName = map[string]string{
	GroupNameRoot: GroupNameRoot,
	"Photo":       GroupNameRoot,
	"Image":       GroupNameRoot,
	"MpfInfo":     GroupNameRoot,
	"GPSInfo":     GroupNameGPS,
	"Iop":         GroupNameIOP,
}

// Please do NOT edit code after this line.
//
//	The code is generated by the codeGen system.
//	cd codeGen
//	go run .
//
//	This file is read, updated and replaces ../imageTagData.go
//	This file must compile and run as part of the codeGen system
const CodeGenBarrier = "CG // Code Gen Barrier" // All text after this line is re-generated

var MapTiffFormats = map[TiffFormat]*TagFormat{}
var MapTagsGrouped = map[string]map[uint32]*Tag{}
